# 学习笔记
## 微服务概览
### 单体架构
Q: 由于是单体式应用，打包时过于庞大。应用无法扩展，可靠性低。无法完成敏捷开发与部署。  
A: 应用内部模块化，分而治之。
### 微服务起源
Q: 微服务与SOA(Service-Oriented Architecture)的关系  
A: 微服务是SOA的一种实践  
Q: 微服务要点  
A:  
- 小既是美。 
- 单一职责。  
- 从单db到多db。  
- 尽可能早的创建原型(即先与前端约定接口服务,保证服务间沟通的一致性)。  
- 可移植性比效率更重要(比如从多协议到单一协议，gRPC)。
### 微服务定义
- **原子服务**：按功能划分只关注单一业务、闭环业务。颗粒度粗属于初级划分
- **独立进程**：虚拟化技术，每个服务独立虚拟环境部署。
- **隔离部署**：由于Docker的发展推动了微服务的发展。通过对每个服务的隔离部署，不会出现一个服务挂掉导致所有服务挂掉的问题。
- **去中心化服务治理**：后面会提
- **基础设施的建设、复杂度高**：这是问题，解决方案：利用大量的中间件与微服务基础设施弥补
### 微服务不足
- 对于消息的传递与通信要求高。
    - Q1: 可能因为烂代码(如for循环查询)造成上游到下游的网络请求成倍大增。A1: batch化，提供粗粒度的批量接口。 
    - Q2: 串行化造成消息传递过慢。A2: 改串行为并行
- 由于微服务的多db特性，在db的一致性与事务的处理上是一个更高难度的挑战。
- 测试微服务应用成为难题。
- 服务间的模块会形成依赖，当对某个服务进行升级修改时，可能造成多个服务模块的修改。
- 对运维基础设施的挑战难度加大。Q: 多机器问题无法排查。A: 日志统一采集，指标汇总，监控体系升级，报警系统升级，用上k8s。
### 组件服务化
- 将单体应用的多组件拆分为多服务化每个服务化单一组件。好处是：单一服务的变更不会影响到全部的服务
- Q: 如何利用go实施一个微服务？ A: 1、kit: 微服务基础库(如 go-kit、go-mirco) 2、service: 业务代码+kit依赖+第三方依赖组成的业务微服务 3、rpc+message queue: 利用rpc协议(gRPC)和消息队列(kafka)实现轻量级通信
- 组件服务化的本质：多个微服务组合构成的完整用户场景(即可交付的可给用户使用的项目)
### 按业务组织服务
- **团队结构**：
    - 烟囱式(垂直划分): 开发与运维只负责职位职能范围内的事。即开发只开发不了解如何发布服务。
    - 全栈：开发需要为整个业务场景负责，从测试到发布到监控都由开发一手包办，因为开发最了解自己的代码。测试与运维平台化、开发化，由测试与运维开发相应的测试平台、发布平台、日志采集平台、监控平台等。
- **团队模式**
    - 大前端 <=> 网关: 大前端与网关团队形成闭环。
    - 网关 <=> 业务服务: 通过API对接
    - 测试与运维: 提供好用的基础设施
- **开发团队对软件在生产环境的运行负全部责任**: You build it, You fix it.
### 去中心化
## 微服务设计
## gRPC & 服务发现
## 多集群 & 多租户